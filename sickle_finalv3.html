<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D RBC vs Sickle - High Edge Density</title>
    <style>
        body { margin: 0; background: #020202; color: white; font-family: sans-serif; overflow: hidden; display: flex; }
        .viewport { flex: 1; height: 100vh; position: relative; border-right: 2px solid #222; }
        #ui { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); z-index: 1000; background: rgba(20,20,20,0.95); padding: 15px 30px; border-radius: 40px; border: 1px solid #444; text-align: center; }
        .header { position: absolute; top: 20px; left: 20px; color: #ff4444; font-weight: bold; font-size: 1rem; }
        .info { position: absolute; bottom: 30px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; border-left: 4px solid #ffcc33; max-width: 300px; font-size: 0.85rem; pointer-events: none; line-height: 1.4; }
        .legend-tag { margin-top: 10px; display: flex; align-items: center; color: #ffcc33; font-weight: bold; }
        .dot { width: 10px; height: 10px; background: #ffcc33; border-radius: 50%; display: inline-block; margin-right: 8px; }
        input[type=range] { width: 220px; cursor: pointer; accent-color: #ff4444; }
        .slider-labels { display: flex; justify-content: space-between; font-size: 0.65rem; color: #888; margin-top: 4px; font-weight: bold;}
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-size: 0.7rem; color: #aaa; margin-bottom: 5px; font-weight: bold;">VIEW INTERNAL STRUCTURE</div>
        <input type="range" id="opac" min="0" max="1" step="0.01" value="0.4">
        <div class="slider-labels"><span>OPAQUE</span><span>TRANSPARENT</span></div>
    </div>

    <div id="v1" class="viewport"><div class="header">NORMAL RED BLOOD CELL</div>
        <div class="info"><b>Biconcave Disc:</b> HbA is soluble. Density is higher at the thick rim.
            <div class="legend-tag"><span class="dot"></span> Haemoglobin (HbA)</div>
        </div>
    </div>

    <div id="v2" class="viewport"><div class="header">SICKLE RED BLOOD CELL</div>
        <div class="info"><b>Sickle Shape:</b> Rigid HbS fibers stretch the cell into a crescent.
            <div class="legend-tag"><span class="dot"></span> Haemoglobin (HbS)</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scenes = [], cameras = [], renderers = [], controls = [], cellMats = [];

        function createNormalGeo() {
            const pts = [];
            const R = 2.9; // Increased further for better internal volume
            for (let i = 0; i <= 40; i++) {
                const t = (i / 40) * Math.PI; 
                const r = Math.sin(t) * R;
                const x2 = (r/R)*(r/R);
                const x4 = x2*x2;
                let h = 0.5 * R * Math.sqrt(Math.max(0, 1 - x2)) * (0.207 + 2.003*x2 - 1.123*x4);
                let y = Math.cos(t) > 0 ? h : -h;
                pts.push(new THREE.Vector2(r, y));
            }
            return new THREE.LatheGeometry(pts, 64);
        }

        function createSickleGeo() {
            const curvePoints = [];
            for (let i = 0; i <= 20; i++) {
                const t = (i / 20) * Math.PI;
                curvePoints.push(new THREE.Vector3(Math.cos(t) * 3.6, Math.sin(t) * 2.4, 0));
            }
            const path = new THREE.CatmullRomCurve3(curvePoints);
            const geo = new THREE.TubeGeometry(path, 80, 1.1, 24, false);
            const pos = geo.attributes.position;
            const tempV = new THREE.Vector3();
            for (let i = 0; i < pos.count; i++) {
                tempV.fromBufferAttribute(pos, i);
                const u = (Math.floor(i / 25)) / 80; 
                const taper = 0.4 + Math.pow(Math.abs(u - 0.5) * 2, 1.8) * 0.6;
                const finalScale = taper * Math.sin(u * Math.PI);
                const centerPoint = path.getPointAt(u);
                tempV.sub(centerPoint).multiplyScalar(finalScale).add(centerPoint);
                pos.setXYZ(i, tempV.x, tempV.y, tempV.z);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function init() {
            [document.getElementById('v1'), document.getElementById('v2')].forEach((div, i) => {
                const scene = new THREE.Scene();
                const cam = new THREE.PerspectiveCamera(45, div.clientWidth / div.clientHeight, 0.1, 1000);
                cam.position.set(0, 0, 12);

                const ren = new THREE.WebGLRenderer({ antialias: true });
                ren.setSize(div.clientWidth, div.clientHeight);
                div.appendChild(ren.domElement);

                scene.add(new THREE.AmbientLight(0xffffff, 0.5));
                const light = new THREE.PointLight(0xffffff, 1.2);
                light.position.set(5, 10, 5);
                scene.add(light);

                const group = new THREE.Group();
                const mat = new THREE.MeshPhongMaterial({ color: 0xaa0000, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                const cell = new THREE.Mesh(i === 0 ? createNormalGeo() : createSickleGeo(), mat);
                group.add(cell);
                cellMats.push(mat);

                const hbCount = i === 0 ? 2500 : 5000; 
                const inst = new THREE.InstancedMesh(
                    new THREE.SphereGeometry(0.06, 8, 8), 
                    new THREE.MeshPhongMaterial({color: 0xffdd44, emissive: 0xffaa00, emissiveIntensity: 0.5}), 
                    hbCount
                );
                const dummy = new THREE.Object3D();

                if (i === 0) {
                    for (let j = 0; j < hbCount; j++) {
                        // Math.sqrt(Math.random()) creates a bias towards the outer edges (Radius 2.6)
                        const r = Math.sqrt(Math.random()) * 2.6;
                        const t = Math.random() * Math.PI * 2;
                        // Height profile follows the biconcave shape roughly
                        const heightLimit = (r < 1.0) ? 0.3 : 0.7; 
                        dummy.position.set(Math.cos(t)*r, (Math.random()-0.5)*heightLimit, Math.sin(t)*r);
                        dummy.updateMatrix();
                        inst.setMatrixAt(j, dummy.matrix);
                    }
                } else {
                    let idx = 0;
                    for (let c = 0; c < 180; c++) {
                        let u = Math.random();
                        const taper = (0.4 + Math.pow(Math.abs(u - 0.5) * 2, 1.8) * 0.6) * Math.sin(u * Math.PI);
                        let fiberMax = (u > 0.3 && u < 0.7) ? 11 : 9;
                        const chainLength = Math.max(0, Math.floor(fiberMax * taper));
                        const t = u * Math.PI;
                        const startX = Math.cos(t) * 3.6;
                        const startY = Math.sin(t) * 2.4;
                        const dir = new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1).normalize();
                        for (let s = 0; s < chainLength; s++) {
                            const px = startX + dir.x * s * 0.12;
                            const py = startY + dir.y * s * 0.12;
                            const pz = dir.z * s * 0.12;
                            if (idx < hbCount) {
                                dummy.position.set(px, py, pz);
                                dummy.updateMatrix();
                                inst.setMatrixAt(idx++, dummy.matrix);
                            }
                        }
                    }
                }
                group.add(inst);
                scene.add(group);
                const ctrl = new THREE.OrbitControls(cam, ren.domElement);
                scenes.push(scene); cameras.push(cam); renderers.push(ren); controls.push(ctrl);
            });

            document.getElementById('opac').oninput = (e) => {
                const val = parseFloat(e.target.value);
                cellMats.forEach(m => { m.opacity = 1 - val; });
            };
        }

        function animate() {
            requestAnimationFrame(animate);
            renderers.forEach((r, i) => r.render(scenes[i], cameras[i]));
        }
        init(); animate();
    </script>
</body>
</html>