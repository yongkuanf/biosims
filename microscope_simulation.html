<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Microscope Eyepiece Graticule Calibration Simulation</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 20px;
      background-color: #f0f0f0;
    }
    #microscopeView {
      border: 1px solid black;
      background-color: #ffffff;
    }
    #controls, #movement, #steps, #calculations {
      margin: 10px 0;
      padding: 10px;
      border: 1px solid #ccc;
      background-color: #fff;
      width: 600px;
    }
    button {
      margin: 5px;
      padding: 5px 10px;
    }
    #result {
      margin-top: 10px;
      font-weight: bold;
      color: green;
    }
    input[type="number"] {
      width: 60px;
      margin: 5px;
    }
    #calculations div {
      margin-left: 20px;
      line-height: 2;
    }
    .legend {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .legend div {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .dash {
      width: 20px;
      height: 2px;
      display: inline-block;
    }
    .blue-dash {
      background-color: blue;
    }
    .red-dash {
      background-color: red;
    }
    .magnification {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 12px;
      font-weight: bold;
    }
    .stage-note {
      position: absolute;
      bottom: 10px;
      right: 10px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h1>Microscope Eyepiece Graticule Calibration Simulation</h1>
  <div style="position: relative;">
    <canvas id="microscopeView" width="600" height="400"></canvas>
    <div class="magnification" id="magDisplay">Magnification: 40x</div>
    <div class="legend">
      <div><span class="dash blue-dash"></span> Eyepiece Graticule</div>
      <div><span class="dash red-dash"></span> Stage Micrometer</div>
    </div>
    <div class="stage-note">For stage micrometer, 1 DIV = 0.01mm</div>
  </div>
  
  <div id="controls">
    <strong>Magnification:</strong>
    <button onclick="setMag(4)">4x</button>
    <button onclick="setMag(10)">10x</button>
    <button onclick="setMag(40)">40x</button>
    <button onclick="setMag(60)">60x</button>
  </div>
  
  <div id="movement">
    <strong>Move Stage Micrometer:</strong>
    <button onclick="moveStage(0, -5)">Up</button>
    <button onclick="moveStage(0, 5)">Down</button>
    <button onclick="moveStage(-5, 0)">Left</button>
    <button onclick="moveStage(5, 0)">Right</button>
  </div>
  
  <div id="steps">
    <strong>To calibrate:</strong>
    <ol>
      <li>Set the magnification desired.</li>
      <li>Align the '0' of the stage micrometer and the eyepiece graticule.</li>
      <li>Indicate the number of eyepiece graticule units (eu) that is aligned to the number of stage units (su).</li>
      <li>Calculate the length of 1 eu in mm.</li>
      <li>You can change magnification and repeat steps 2 to 4.</li>
    </ol>
  </div>
  
  <div id="calculations">
    <p>Step 3: Find the number of eu that is aligned to the number of su.</p>
    <div><input id="eu" type="number" min="0" step="any"> eu = <input id="su" type="number" min="0" step="any"> su</div>
    <p>Next, convert su to mm, by referring to the 'slide', look for '1 DIV = 0.01 mm', DIV here refers to 1 su.</p>
    <div><input id="eu2" type="number" min="0" step="any"> eu = <input id="mm" type="number" min="0" step="any"> mm</div>
    <p>Next, calculate the length of 1 eu in mm.</p>
    <div>1 eu = <input id="one_mm" type="number" min="0" step="any"> mm</div>
    <p>Finally, convert mm to &mu;m (for calibration, it is usually in &mu;m, unless otherwise specified by the question).</p>
    <div>1 eu = <input id="one_um" type="number" min="0" step="any"> &mu;m</div>
    <button onclick="checkCalc()">Check my calculations</button>
    <div id="result"></div>
  </div>

  <script>
    const canvas = document.getElementById('microscopeView');
    const ctx = canvas.getContext('2d');
    const canvasCenterX = canvas.width / 2;
    const canvasCenterY = canvas.height / 2;
    const fieldRadius = 180;
    const scaleLength = fieldRadius * 1.8; // Base scale length for eyepiece
    const scaleStartX = canvasCenterX - scaleLength / 2;
    const scaleEndX = canvasCenterX + scaleLength / 2;
    const totalScalePx = scaleLength;
    const euSmallPx = totalScalePx / 100;
    const eyepieceY = canvasCenterY - 20;
    const baseStageY = canvasCenterY + 20;

    let currentMag = 40;
    let stageXOffset = 0;
    let stageYOffset = 0;

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw circular field of view
      ctx.beginPath();
      ctx.arc(canvasCenterX, canvasCenterY, fieldRadius, 0, Math.PI * 2);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.clip(); // Clip to field of view

      // Eyepiece graticule (fixed, centered)
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 1;
      // Base line
      ctx.beginPath();
      ctx.moveTo(scaleStartX, eyepieceY);
      ctx.lineTo(scaleEndX, eyepieceY);
      ctx.stroke();
      // Ticks and labels
      for (let i = 0; i <= 100; i++) {
        const x = scaleStartX + i * euSmallPx;
        const height = (i % 10 === 0) ? 20 : 10;
        ctx.beginPath();
        ctx.moveTo(x, eyepieceY - height / 2);
        ctx.lineTo(x, eyepieceY + height / 2);
        ctx.stroke();
      }
      for (let j = 0; j <= 10; j++) {
        const x = scaleStartX + j * 10 * euSmallPx;
        ctx.fillStyle = 'blue';
        ctx.fillText(j, x - 5, eyepieceY - 15);
      }

      // Stage micrometer (movable and scalable)
      const suPer100Eu = 1000 / currentMag; // Number of stage small units per 100 eyepiece units
      const scaleFactor = currentMag === 4 ? 1.2 : 1; // Slightly increase scale at 4x
      const stageSmallPx = (totalScalePx / suPer100Eu) * scaleFactor;
      const stageY = baseStageY + stageYOffset;
      ctx.strokeStyle = 'red';
      // Base line
      ctx.lineWidth = currentMag === 4 ? 0.5 : 1; // Thinner base line at 4x
      const stageZeroX = scaleStartX + stageXOffset;
      const startI = Math.max(0, Math.floor((canvasCenterX - fieldRadius - stageZeroX) / stageSmallPx));
      const endI = Math.min(100, Math.ceil((canvasCenterX + fieldRadius - stageZeroX) / stageSmallPx));
      const lineStartX = Math.max(canvasCenterX - fieldRadius, stageZeroX);
      const lineEndX = Math.min(canvasCenterX + fieldRadius, stageZeroX + 100 * stageSmallPx);
      if (lineStartX < lineEndX) {
        ctx.beginPath();
        ctx.moveTo(lineStartX, stageY);
        ctx.lineTo(lineEndX, stageY);
        ctx.stroke();
      }
      // Ticks (draw all divisions)
      for (let i = startI; i <= endI; i++) {
        const x = stageZeroX + i * stageSmallPx;
        const height = (i % 10 === 0) ? 20 : (currentMag === 4 ? 6 : 10); // Smaller minor ticks at 4x
        ctx.lineWidth = (currentMag === 4 && i % 10 !== 0) ? 0.3 : (currentMag === 4 ? 0.5 : 1); // Thinner minor ticks at 4x
        ctx.beginPath();
        ctx.moveTo(x, stageY - height / 2);
        ctx.lineTo(x, stageY + height / 2);
        ctx.stroke();
      }

      ctx.restore(); // Restore context to remove clipping
    }

    function setMag(mag) {
      currentMag = mag;
      document.getElementById('magDisplay').textContent = `Magnification: ${mag}x`;
      draw();
    }

    function moveStage(dx, dy) {
      stageXOffset += dx;
      stageYOffset += dy;
      draw();
    }

    function checkCalc() {
      const eu = parseFloat(document.getElementById('eu').value);
      const su = parseFloat(document.getElementById('su').value);
      const eu2 = parseFloat(document.getElementById('eu2').value);
      const mm = parseFloat(document.getElementById('mm').value);
      const oneMm = parseFloat(document.getElementById('one_mm').value);
      const oneUm = parseFloat(document.getElementById('one_um').value);
      const resultDiv = document.getElementById('result');

      if (isNaN(eu) || isNaN(su) || isNaN(eu2) || isNaN(mm) || isNaN(oneMm) || isNaN(oneUm)) {
        resultDiv.textContent = 'Please fill all boxes with numbers.';
        resultDiv.style.color = 'red';
        return;
      }

      if (Math.abs(eu - eu2) > 0.001) {
        resultDiv.textContent = 'The eu counts should match.';
        resultDiv.style.color = 'red';
        return;
      }

      const stageSmallMm = 0.01; // 1 DIV = 0.01 mm
      const expectedMm = su * stageSmallMm;

      if (Math.abs(mm - expectedMm) > 0.001) {
        resultDiv.textContent = 'Try again!';
        resultDiv.style.color = 'red';
        return;
      }

      const expectedOneMm = mm / eu;

      if (Math.abs(oneMm - expectedOneMm) > 0.0001) {
        resultDiv.textContent = 'Try again!';
        resultDiv.style.color = 'red';
        return;
      }

      const expectedOneUm = oneMm * 1000;

      if (Math.abs(oneUm - expectedOneUm) > 0.1) {
        resultDiv.textContent = 'Try again!';
        resultDiv.style.color = 'red';
        return;
      }

      resultDiv.textContent = "That's right!";
      resultDiv.style.color = 'green';
    }

    // Initial draw
    draw();
  </script>
</body>
</html>