<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H2 Math: 3D Vector Playground</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --vector-a: #fb7185;
            --vector-b: #22d3ee;
            --vector-res: #a7f3d0;
        }

        body, html {
            margin: 0; padding: 0; height: 100%; width: 100%;
            overflow: hidden; font-family: sans-serif;
            display: flex; background: #000;
        }

        #canvas-container {
            flex-grow: 1;
            height: 100vh;
            position: relative;
        }

        #controls {
            width: 350px;
            background: var(--panel);
            color: white;
            padding: 20px;
            box-shadow: -2px 0 10px rgba(0,0,0,0.5);
            z-index: 100;
            overflow-y: auto;
        }

        .input-group {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 5px solid gray;
        }

        input {
            width: 60px;
            background: #334155;
            border: 1px solid #475569;
            color: white;
            padding: 5px;
            border-radius: 4px;
        }

        #error-log {
            position: absolute;
            top: 10px; left: 10px;
            color: #f87171; font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px; pointer-events: none;
        }

        .stats { font-family: monospace; color: var(--vector-res); line-height: 1.6; }
    </style>
</head>
<body>

    <div id="error-log">Initializing 3D Engine...</div>
    <div id="canvas-container"></div>

    <div id="controls">
        <h2 style="color: var(--vector-res)">Vector Solver 3D</h2>
        
        <div class="input-group" style="border-color: var(--vector-a)">
            <strong>Vector A (Red)</strong><br><br>
            x: <input type="number" id="ax" value="2">
            y: <input type="number" id="ay" value="3">
            z: <input type="number" id="az" value="1">
        </div>

        <div class="input-group" style="border-color: var(--vector-b)">
            <strong>Vector B (Blue)</strong><br><br>
            x: <input type="number" id="bx" value="-1">
            y: <input type="number" id="by" value="2">
            z: <input type="number" id="bz" value="3">
        </div>

        <div class="input-group" style="border-color: white">
            <strong>Calculations</strong><br><br>
            <div id="output" class="stats"></div>
        </div>

        <p style="font-size: 0.8rem; color: #94a3b8;">
            Drag to Rotate • Scroll to Zoom<br>
            Right-click to Pan
        </p>
    </div>

    <script>
        // Diagnostic check
        window.onerror = function(msg) {
            document.getElementById('error-log').innerHTML = "Error: " + msg;
        };

        let scene, camera, renderer, controls, arrowA, arrowB, arrowC, plane;

        function init() {
            const container = document.getElementById('canvas-container');
            
            // 1. Scene & Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // 3. Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            
            // 4. Grid & Axes
            const grid = new THREE.GridHelper(10, 10, 0x475569, 0x334155);
            scene.add(grid);
            const axes = new THREE.AxesHelper(5);
            scene.add(axes);

            // 5. Lighting
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 5, 5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            document.getElementById('error-log').style.display = 'none';
            
            setupInputs();
            updateScene();
            animate();
        }

        function updateScene() {
            if(arrowA) scene.remove(arrowA);
            if(arrowB) scene.remove(arrowB);
            if(arrowC) scene.remove(arrowC);
            if(plane) scene.remove(plane);

            const a = new THREE.Vector3(
                parseFloat(document.getElementById('ax').value) || 0,
                parseFloat(document.getElementById('ay').value) || 0,
                parseFloat(document.getElementById('az').value) || 0
            );

            const b = new THREE.Vector3(
                parseFloat(document.getElementById('bx').value) || 0,
                parseFloat(document.getElementById('by').value) || 0,
                parseFloat(document.getElementById('bz').value) || 0
            );

            // Draw A and B
            arrowA = new THREE.ArrowHelper(a.clone().normalize(), new THREE.Vector3(0,0,0), a.length(), 0xfb7185, 0.3, 0.15);
            arrowB = new THREE.ArrowHelper(b.clone().normalize(), new THREE.Vector3(0,0,0), b.length(), 0x22d3ee, 0.3, 0.15);
            scene.add(arrowA);
            scene.add(arrowB);

            // Cross Product
            const cp = new THREE.Vector3().crossVectors(a, b);
            arrowC = new THREE.ArrowHelper(cp.clone().normalize(), new THREE.Vector3(0,0,0), cp.length(), 0xa7f3d0, 0.3, 0.15);
            scene.add(arrowC);

            // Parallelogram Area
            const vertices = new Float32Array([
                0,0,0, a.x,a.y,a.z, a.x+b.x,a.y+b.y,a.z+b.z, b.x,b.y,b.z
            ]);
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geo.setIndex([0, 1, 2, 0, 2, 3]);
            plane = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0xa7f3d0, side: THREE.DoubleSide, transparent: true, opacity: 0.2 }));
            scene.add(plane);

            // Math Results
            const dot = a.dot(b);
            const angle = (a.length() * b.length() === 0) ? 0 : Math.acos(Math.min(Math.max(dot/(a.length()*b.length()), -1), 1)) * (180/Math.PI);
            
            document.getElementById('output').innerHTML = `
                Dot Product: ${dot.toFixed(2)}<br>
                Angle: ${angle.toFixed(1)}°<br>
                Cross (x,y,z): [${cp.x.toFixed(1)}, ${cp.y.toFixed(1)}, ${cp.z.toFixed(1)}]<br>
                Area: ${cp.length().toFixed(2)}
            `;
        }

        function setupInputs() {
            document.querySelectorAll('input').forEach(i => i.addEventListener('input', updateScene));
            window.addEventListener('resize', () => {
                const container = document.getElementById('canvas-container');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Run after libraries load
        window.onload = init;
    </script>
</body>
</html>
